<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fully Movable Flexible Wiring Circuit</title>
    <style>
        body { 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #f0f0f0; 
            /* Disable default text selection during dragging */
            user-select: none; 
            -webkit-user-select: none;
            -moz-user-select: none;
        }
        svg { 
            border: 1px solid #ccc; 
            background-color: white; 
            cursor: default; /* Reset cursor for SVG area */
        }

        /* Component Styles */
        .movable-component { 
            cursor: grab; /* Indicate draggable element */
        }
        .movable-component:active { 
            cursor: grabbing; 
        }
        .meter-case { fill: #333; stroke: black; stroke-width: 2; }
        .meter-dial { fill: white; }
        .meter-needle { 
            stroke: red; 
            stroke-width: 3; 
            stroke-linecap: round;
            transition: transform 0.8s ease-out; 
        }
        .label { font-family: sans-serif; font-size: 14px; font-weight: bold; text-anchor: middle; }
        
        /* Terminal & Wire Styles */
        .terminal { stroke: black; stroke-width: 1; cursor: pointer; }
        .terminal.pos { fill: red; } 
        .terminal.neg { fill: blue; } 
        .terminal.connected { opacity: 0.5; } 

        .dynamic-wire { stroke: black; stroke-width: 3; fill: none; stroke-linecap: round; }
        .dynamic-wire.connected { stroke: red; } 

        /* Battery Styles */
        .battery-line { stroke: black; stroke-width: 4; stroke-linecap: round; }
    </style>
</head>
<body>

<svg id="circuit-svg" width="800" height="450" viewbox="0 0 800 450">
    
    <g id="power-source" class="movable-component" data-x="100" data-y="100" transform="translate(100, 100)">
        <rect x="-30" y="-30" width="80" height="60" fill="none" stroke="none"/>
        <line x1="0" y1="-20" x2="0" y2="20" class="battery-line"/>
        <line x1="15" y1="-10" x2="15" y2="10" class="battery-line"/>
        <text x="35" y="0" class="label">DC</text>
        
        <circle id="t-P1" cx="-25" cy="-25" r="5" class="terminal pos" data-type="pos"/> <circle id="t-P2" cx="-25" cy="25" r="5" class="terminal neg" data-type="neg"/> </g>

    <g id="ammeter" class="movable-component" data-x="400" data-y="100" transform="translate(400, 100)">
        <rect x="0" y="0" width="100" height="60" rx="5" class="meter-case"/>
        <circle cx="50" cy="30" r="25" class="meter-dial"/>
        <text x="50" y="55" class="label" fill="#333">A</text>
        
        <line id="a-needle" x1="50" y1="30" x2="50" y2="10" class="meter-needle" 
              style="transform-origin: 50px 30px; transform: rotate(-45deg);"/>
        
        <circle id="t-A1" cx="50" cy="0" r="5" class="terminal pos" data-type="pos"/> 
        <circle id="t-A2" cx="50" cy="60" r="5" class="terminal neg" data-type="neg"/> 
    </g>

    <g id="voltmeter" class="movable-component" data-x="400" data-y="300" transform="translate(400, 300)">
        <rect x="0" y="0" width="100" height="60" rx="5" class="meter-case"/>
        <circle cx="50" cy="30" r="25" class="meter-dial"/>
        <text x="50" y="55" class="label" fill="#333">V</text>
        
        <line id="v-needle" x1="50" y1="30" x2="50" y2="10" class="meter-needle" 
              style="transform-origin: 50px 30px; transform: rotate(-45deg);"/>
        
        <circle id="t-V1" cx="50" cy="0" r="5" class="terminal pos" data-type="pos"/> 
        <circle id="t-V2" cx="50" cy="60" r="5" class="terminal neg" data-type="neg"/> 
    </g>
    
</svg>

<script>
    // --- JAVASCRIPT LOGIC FOR MOVABLE COMPONENTS, WIRING, AND METER UPDATES ---

    const svg = document.getElementById('circuit-svg');
    const terminals = document.querySelectorAll('.terminal');
    const movableComponents = document.querySelectorAll('.movable-component');
    const aNeedle = document.getElementById('a-needle');
    const vNeedle = document.getElementById('v-needle');

    let isDraggingComponent = false;
    let isDraggingWire = false;
    let activeComponent = null;
    let offset = { x: 0, y: 0 }; // Used for component dragging offset
    
    let currentWire = null;
    let startTerminal = null;
    const snapRadius = 15; 
    let connections = []; // { wire: <path>, start: <circle>, end: <circle> }

    // --- CIRCUIT CONSTANTS ---
    const VOLTAGE = 12.0; 
    const RESISTANCE = 30.0;
    const CURRENT = VOLTAGE / RESISTANCE; 
    const MAX_ROTATION = 90; 

    // Helper to convert mouse coordinates to SVG coordinates
    function getSVGPoint(evt) {
        let pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        return pt.matrixTransform(svg.getScreenCTM().inverse());
    }

    // Returns the absolute (x, y) coordinates of a terminal
    function getTerminalAbsolutePosition(terminal) {
        // Find the parent movable component group (the G element)
        let parentG = terminal.closest('.movable-component');
        if (!parentG) return { x: 0, y: 0 };

        // Read the current position from the 'data-x' and 'data-y' attributes
        const componentX = parseFloat(parentG.getAttribute('data-x'));
        const componentY = parseFloat(parentG.getAttribute('data-y'));

        // Terminal's coordinates are relative to the component's (0, 0)
        const terminalX = parseFloat(terminal.getAttribute('cx'));
        const terminalY = parseFloat(terminal.getAttribute('cy'));

        // Absolute Position = Component Position + Terminal Relative Position
        return {
            x: componentX + terminalX,
            y: componentY + terminalY
        };
    }
    
    // Function to generate the flexible (Manhattan) path data
    function getFlexiblePath(startX, startY, endX, endY) {
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        const dx = Math.abs(startX - endX);
        const dy = Math.abs(startY - endY);

        let pathData = `M ${startX} ${startY}`;

        // Prioritize horizontal-vertical-horizontal if connection is mostly horizontal
        if (dx > dy * 1.5) { // Use 1.5 multiplier for better routing decision
            pathData += ` L ${midX} ${startY}`;
            pathData += ` L ${midX} ${endY}`;
            pathData += ` L ${endX} ${endY}`;
        } 
        // Prioritize vertical-horizontal-vertical if connection is mostly vertical
        else if (dy > dx * 1.5) {
            pathData += ` L ${startX} ${midY}`;
            pathData += ` L ${endX} ${midY}`;
            pathData += ` L ${endX} ${endY}`;
        }
        // Use simpler vertical then horizontal for complex diagonal movements
        else {
            pathData += ` L ${startX} ${midY}`;
            pathData += ` L ${endX} ${midY}`;
            pathData += ` L ${endX} ${endY}`;
        }

        return pathData;
    }

    // Function to redraw all existing wires (called when a component moves)
    function redrawWires() {
        connections.forEach(conn => {
            const startPos = getTerminalAbsolutePosition(conn.start);
            const endPos = getTerminalAbsolutePosition(conn.end);
            const pathData = getFlexiblePath(startPos.x, startPos.y, endPos.x, endPos.y);
            conn.wire.setAttribute('d', pathData);
        });
    }

    // Function to calculate and update meter needles (simplified logic retained)
    function updateMeterNeedles() {
        // Find connections based on terminal IDs
        let ammeterCorrectlyWired = connections.some(c => c.start.id === 't-P1' && c.end.id === 't-A1') && connections.some(c => c.start.id === 't-A2' && c.end.id === 't-P2');
        let voltmeterCorrectlyWired = connections.some(c => c.start.id === 't-P1' && c.end.id === 't-V1') && connections.some(c => c.start.id === 't-V2' && c.end.id === 't-P2');

        const I = ammeterCorrectlyWired ? CURRENT : 0;
        const V = voltmeterCorrectlyWired ? VOLTAGE : 0;
        
        // Ammeter Angle
        const MAX_A_READING = 0.5;
        let aAngle = (I / MAX_A_READING) * MAX_ROTATION - (MAX_ROTATION / 2);
        aNeedle.style.transform = `rotate(${Math.min(aAngle, MAX_ROTATION/2)}deg)`;

        // Voltmeter Angle
        const MAX_V_READING = 20.0;
        let vAngle = (V / MAX_V_READING) * MAX_ROTATION - (MAX_ROTATION / 2);
        vNeedle.style.transform = `rotate(${Math.min(vAngle, MAX_ROTATION/2)}deg)`;

        // Reset needles if incorrect polarity/incomplete circuit
        if (!ammeterCorrectlyWired) aNeedle.style.transform = `rotate(-45deg)`;
        if (!voltmeterCorrectlyWired) vNeedle.style.transform = `rotate(-45deg)`;
    }

    // --- Component Dragging Logic ---

    // Start dragging a component
    movableComponents.forEach(component => {
        component.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('terminal')) return; // Ignore if clicking a terminal (wire drag takes precedence)

            isDraggingComponent = true;
            activeComponent = component;
            activeComponent.classList.add('grabbing');
            
            const pt = getSVGPoint(e);
            
            // Calculate offset between mouse click and component origin
            const componentX = parseFloat(component.getAttribute('data-x'));
            const componentY = parseFloat(component.getAttribute('data-y'));
            offset.x = pt.x - componentX;
            offset.y = pt.y - componentY;
        });
    });

    // --- Wiring Logic (Mousedown on Terminal) ---
    terminals.forEach(terminal => {
        terminal.addEventListener('mousedown', (e) => {
            e.preventDefault(); 
            e.stopPropagation(); // Stop event from bubbling up to component drag handler

            isDraggingWire = true;
            startTerminal = terminal;
            terminal.classList.add('connected');
            
            // Allow re-wiring (delete existing wire)
            connections = connections.filter(conn => {
                if (conn.start === terminal || conn.end === terminal) {
                    conn.wire.remove();
                    conn.start.classList.remove('connected');
                    conn.end.classList.remove('connected');
                    return false;
                }
                return true;
            });
            updateMeterNeedles();

            // Create new wire
            currentWire = document.createElementNS("http://www.w3.org/2000/svg", "path");
            currentWire.classList.add('dynamic-wire');
            svg.appendChild(currentWire);

            const startPos = getTerminalAbsolutePosition(terminal);
            currentWire.setAttribute('d', `M ${startPos.x} ${startPos.y} L ${startPos.x} ${startPos.y}`);
        });
    });


    // --- Global Mouse Move ---
    document.addEventListener('mousemove', (e) => {
        const pt = getSVGPoint(e);

        if (isDraggingComponent && activeComponent) {
            // 1. Move the Component
            e.preventDefault();
            
            const newX = pt.x - offset.x;
            const newY = pt.y - offset.y;
            
            // Update data attributes and transform
            activeComponent.setAttribute('data-x', newX);
            activeComponent.setAttribute('data-y', newY);
            activeComponent.setAttribute('transform', `translate(${newX}, ${newY})`);
            
            // 2. Redraw Wires attached to this component
            redrawWires();

        } else if (isDraggingWire && currentWire) {
            // 3. Draw the Flexible Wire
            e.preventDefault();
            
            const startPos = getTerminalAbsolutePosition(startTerminal);
            const pathData = getFlexiblePath(startPos.x, startPos.y, pt.x, pt.y);
            currentWire.setAttribute('d', pathData);
        }
    });


    // --- Global Mouse Up ---
    document.addEventListener('mouseup', (e) => {
        // Reset component dragging state
        if (isDraggingComponent) {
            isDraggingComponent = false;
            if (activeComponent) activeComponent.classList.remove('grabbing');
            activeComponent = null;
        }

        // Handle wire dropping/snapping
        if (isDraggingWire) {
            isDraggingWire = false;

            const endPoint = getSVGPoint(e);
            let endTerminal = null;

            // Check for snapping
            terminals.forEach(terminal => {
                const termPos = getTerminalAbsolutePosition(terminal);
                const dist = Math.sqrt(Math.pow(endPoint.x - termPos.x, 2) + Math.pow(endPoint.y - termPos.y, 2));

                if (dist < snapRadius && terminal !== startTerminal) {
                    endTerminal = terminal;
                }
            });

            if (endTerminal) {
                // --- Successful Connection ---
                const startPos = getTerminalAbsolutePosition(startTerminal);
                const endPos = getTerminalAbsolutePosition(endTerminal);
                
                const finalPathData = getFlexiblePath(startPos.x, startPos.y, endPos.x, endPos.y);
                currentWire.setAttribute('d', finalPathData);
                currentWire.classList.add('connected');
                
                endTerminal.classList.add('connected');
                connections.push({ wire: currentWire, start: startTerminal, end: endTerminal });

                updateMeterNeedles(); 

            } else {
                // --- Failed Connection ---
                currentWire.remove();
                startTerminal.classList.remove('connected');
                updateMeterNeedles(); 
            }

            // Reset wire state
            currentWire = null;
            startTerminal = null;
        }
    });
    
    // Initial state
    updateMeterNeedles();
</script>
</body>
</html>